<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia at Apr 8, 2012 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta name="Date-Revision-yyyymmdd" content="20120408" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                javautil-poi
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
            
        
                <div class="xleft">
        <span id="publishDate">Last Published: 2012-04-08</span>
                  &nbsp;| <span id="projectVersion">Version: 0.11.0</span>
                      </div>
            <div class="xright">                    <a href="./" title="javautil-poi">javautil-poi</a>
              
        
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
             
        
                                <h5>Parent Project</h5>
                  <ul>
                  <li class="none">
                          <a href="../javautil-pom/index.html" title="javautil">javautil</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                                                                                              <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                                                                            <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="testapidocs/index.html" title="Test JavaDocs">Test JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="xref/index.html" title="Source Xref">Source Xref</a>
            </li>
                      <li class="none">
                          <a href="xref-test/index.html" title="Test Source Xref">Test Source Xref</a>
            </li>
                      <li class="none">
                          <a href="pmd.html" title="PMD Report">PMD Report</a>
            </li>
                      <li class="none">
            <strong>CPD Report</strong>
          </li>
                      <li class="none">
                          <a href="cobertura/index.html" title="Cobertura Test Coverage">Cobertura Test Coverage</a>
            </li>
                      <li class="none">
                          <a href="surefire-report.html" title="Surefire Report">Surefire Report</a>
            </li>
              </ul>
        </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                   
        
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section"><h2>CPD Results<a name="CPD_Results"></a></h2><p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 4.3.</p></div><div class="section"><h2>Duplications<a name="Duplications"></a></h2><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#116">116</a></td></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetRenderer.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetRenderer.html#115">115</a></td></tr><tr class="b"><td colspan='2'><div><pre>		final DataRange range = new DataRange();
		if (logger.isDebugEnabled()) {
			logger.debug(&quot;Crosstab, Dataset Metadata has &quot;
					+ dataset.getMetadata().getColumnCount() + &quot; Columns&quot;);
		}
		range.setFirstRow(startingRow);
		range.setFirstColumn(startingColumn);
		range.setDataBeginsRow(startingRow + 1);

		range.setLastColumn(startingColumn + rowIdentifyingColumns.size()
				+ (groupNames.length * nonRowIdentifyingColumns.size()) - 1);

		if (logger.isDebugEnabled()) {
			logger.debug(&quot;Before Emitting Crosstab, Dataset Metadata has &quot;
					+ dataset.getMetadata().getColumnCount() + &quot; Columns&quot;);
		}
		range.setLastRow(startingRow
				+ dataset.getDatasetIterator().getRowCount() + 2);
		range.setFooterBeginsRow(startingRow
				+ dataset.getDatasetIterator().getRowCount() + 2);
		//
		// emit headers
		//

		emitHeadersForRowIdentifiers(dataset, getStyleFactory()
				.getBaseHeaderStyle(), startingRow, startingColumn);

		if (singleCellCrosstabColumnHeading) {
			// emit a spanning column with the group name above the group
			emitCrosstabHeadersForCrosstabData(dataset, groupNames,
					nonRowIdentifyingColumns, metaByColumnName,
					getStyleFactory().getBaseHeaderStyle(), startingRow,
					(sourceRowidColumnIndexes.length));
		} else {
			emitCrosstabHeadersForCrosstabDataWithSpannedHeaders(dataset,
					groupNames, nonRowIdentifyingColumns, metaByColumnName,
					getStyleFactory().getBaseHeaderStyle(), startingRow,
					(sourceRowidColumnIndexes.length));

		}

		//
		// emit data
		//

		final int adjustedStartingRow = isSingleCellCrosstabColumnHeading() ? startingRow + 1
				: startingRow + 2;
		final int lastDataRowIndex = emitCrosstabbedData(dataset, dataset
				.getMetadata().getColumnMetadata(), getStyleFactory()
				.getBaseDataStyle(), adjustedStartingRow, startingColumn,
				rowIdentifyingColumns, nonRowIdentifyingColumns, columnMeta,
				metaByColumnName, groupNames);

		// emit summary

		emitCrosstabbedSummary(dataset, dataset.getMetadata()
				.getColumnMetadata(), lastDataRowIndex + 1, startingColumn,
				startingRow + 1, lastDataRowIndex, getStyleFactory()
						.getBaseFooterStyle(), rowIdentifyingColumns,
				nonRowIdentifyingColumns, columnMeta, metaByColumnName,
				groupNames);

		return range;
	}

	protected void emitCrosstabbedDataValidateArgs(final Dataset dataset,
			final List&lt;ColumnMetadata&gt; _columns, final Style baseStyle,
			final int startingRow, final int startingColumn,
			final List&lt;String&gt; rowIdentifyingColumns) {
		if (dataset == null) {
			throw new IllegalArgumentException(&quot;dataset is null&quot;);
		}
		if (_columns == null) {
			throw new IllegalArgumentException(&quot;columns is null&quot;);
		}
		if (baseStyle == null) {
			throw new IllegalArgumentException(&quot;baseStyle is null&quot;);
		}
	}

	/**
	 * Renders the dataset to the specified region.
	 * 
	 * Creates a freeze frame in the first row after the header after the
	 * rowidColumnCount
	 * 
	 * @param dataset
	 *            The crosstabbed dataset
	 * @param columns
	 *            The Metadata for the crosstabbed columns
	 * @param baseStyle
	 * @param startingRow
	 *            The starting row in the worksheet for emitting the data
	 * @param startingColumn
	 *            The starting column in the worksheet for emitting the data
	 * @param rowIdentifyingColumns
	 *            The number of columns that make up the row identifier.
	 * @param nonIdentifyingRowColumns
	 *            is a list of the order in which the columns should be emitted
	 *            in each crosstabbed group
	 * @param nonRowIdentifyingColumnMetadata
	 *            The metadata for the crosstabbed columns
	 * @param metaMapByColumn
	 *            A HashMap of the Column Metadata for the crosstab columns
	 *            keyed by the Column Name.
	 * @param groupNames
	 *            A List of all the crosstab groups
	 * @return
	 */
	// todo review
	protected int emitCrosstabbedData(final Dataset dataset,
			final List&lt;ColumnMetadata&gt; columns, final Style baseStyle,
			final int startingRow, final int startingColumn,
			final List&lt;String&gt; rowIdentifyingColumns,
			final List&lt;String&gt; nonRowIdentifyingColumns,
			final Collection&lt;ColumnMetadata&gt; nonRowIdentifyingColumnMetadata,
			final Map&lt;String, ColumnMetadata&gt; metaMapByColumn,
			final String[] groupNames) {

		if (logger.isDebugEnabled()) {
			for (final ColumnMetadata col : metaMapByColumn.values()) {
				logger.debug(col);
			}
		}
		// validate arguments
		emitCrosstabbedDataValidateArgs(dataset, columns, baseStyle,
				startingRow, startingColumn, rowIdentifyingColumns);

		final DatasetIterator datasetIterator = dataset.getDatasetIterator();
		if (logger.isTraceEnabled()) {
			logger.trace(newline + ColumnMetadata.toString(columns));
		}
		getSheet().createFreezePane(
				startingColumn + rowIdentifyingColumns.size(), startingRow);
		int rowIndex = startingRow;
		while (datasetIterator.next()) {
			int datasetColumnIndex = startingColumn;
			int sheetColumnIndex = startingColumn;
			// add the data from the dataset in the order of the row identifying
			// columns
			for (final String rowIdentifyingColumn : rowIdentifyingColumns) {
				final ColumnMetadata column = columns.get(datasetColumnIndex);
				final Style cellStyle = getStyle(baseStyle,
						column.getExcelFormat(),
						column.getHorizontalAlignment());
				if (column.getWorkbookFormula() == null) {
					final Object data = datasetIterator
							.getObject(datasetColumnIndex);
					addCell(rowIndex, sheetColumnIndex, data, cellStyle);
				}
				datasetColumnIndex++;
				sheetColumnIndex++;
			}
			int groupIndex = 0;
			for (final String groupName : groupNames) {
				ColumnMetadata column;
				//
				// Map, keyed by column name with value of the index of the
				// column the crosstabbed
				// data for a given column name and group
				//
				// Map&lt;String, Integer&gt; columnIndexByName =
				// ColumnMetadataGrouper.getColumnNameIndexMap(dataset,
				// sheetColumnIndex,
				// nonRowIdentifyingColumnMetadata, groupName);

				final Map&lt;String, Integer&gt; columnIndexByName = getColumnNameIndexMap(
						dataset, sheetColumnIndex,
						nonRowIdentifyingColumnMetadata, groupName,
						nonRowIdentifyingColumns);
				// nonRowIdentifying columns is a list of the order in which the
				// columns should be emitted in each crosstabbed group
				for (final String nonRowIdentifyingColumn : nonRowIdentifyingColumns) {
					final List&lt;Integer&gt; columnIndexes = (List&lt;Integer&gt;) datasetIterator
							.getDatasetMetadata().getColumnIndexes(
									nonRowIdentifyingColumn);
					HSSFCell cell = null;
					if (columnIndexes != null) { // found the specified column
						// in the crosstabbed group
						column = dataset.getMetadata().getColumnMetaData(
								columnIndexes.get(groupIndex));
						final Object data = datasetIterator.getObject(column
								.getColumnIndex());
						cell = addCell(rowIndex, sheetColumnIndex, data, null);
					} else { // this is a formula column, not in the input
						// crosstabbed data
						column = metaMapByColumn.get(nonRowIdentifyingColumn);
						column.setGroupName(groupName);
						cell = addFormulaCell(column.getWorkbookFormula(),
								columnIndexByName, column.getColumnName(),
								rowIndex, sheetColumnIndex);
					}

					final Style cellStyle = getStyle(baseStyle,
							column.getExcelFormat(),
							column.getHorizontalAlignment());
					if ((groupIndex + 1) % 2 == 0) {
						// TODO what the hell is this?? s/b coming from
						// StyleFactory
						final Color color = new Color(192, 192, 192);
						cellStyle.setBackgroundColor(color);
					}
					cell.setCellStyle(getStyleFactory().getHSSFCellStyle(
							cellStyle));

					sheetColumnIndex++;
				}
				groupIndex++;
			}
			rowIndex++;
		}
		return rowIndex - 1;
	}

	private Map&lt;String, Integer&gt; getColumnNameIndexMap(final Dataset dataset,
			final int sheetColumnIndex,
			final Collection&lt;ColumnMetadata&gt; nonRowIdentifyingColumnMetadata,
			final String groupName, final List&lt;String&gt; nonRowIdentifyingColumns) {

		final LinkedHashMap&lt;String, Integer&gt; columnIndexByName = ColumnMetadataGrouper
				.getColumnNameIndexMap(dataset, sheetColumnIndex,
						nonRowIdentifyingColumnMetadata, groupName);

		final LinkedHashMap&lt;String, Integer&gt; columnIndexByNameWithInferred = new LinkedHashMap&lt;String, Integer&gt;();

		// compute the minimum index
		Integer minimumIndex = null;
		for (final Integer index : columnIndexByName.values()) {
			if (minimumIndex == null || minimumIndex.compareTo(index) &gt; 1) {
				minimumIndex = index;
			}
		}

		//
		int columnIndex = minimumIndex;
		for (final String columnName : nonRowIdentifyingColumns) {
			columnIndexByNameWithInferred.put(columnName, columnIndex);
			columnIndex++;
		}

		return columnIndexByNameWithInferred;
	}

	/**
	 * Renders the Summary Row for the Worksheet
	 * 
	 * @param columns
	 *            The Metadata for the crosstabbed columns
	 * @param baseStyle
	 * @param startingRow
	 *            The starting row in the worksheet for emitting the data
	 * @param startingColumn
	 *            The starting column in the worksheet for emitting the data
	 * @param rowIdentifyingColumns
	 *            The number of columns that make up the row identifier.
	 * @param nonIdentifyingRowColumns
	 *            is a list of the order in which the columns should be emitted
	 *            in each crosstabbed group
	 * @param nonRowIdentifyingColumnMetadata
	 *            The metadata for the crosstabbed columns
	 * @param metaMapByColumn
	 *            A HashMap of the Column Metadata for the crosstab columns
	 *            keyed by the Column Name.
	 * @param groupNames
	 *            A List of all the crosstab groups
	 * @return
	 */
	// todo review

	private void emitCrosstabbedSummary(final Dataset dataset,
			final List&lt;ColumnMetadata&gt; columns, final int rowIndex,
			final int columnIndex, final int firstDataRowIndex,
			final int lastDataRowIndex, final Style baseStyle,
			final List&lt;String&gt; rowIdentifyingColumns,
			final List&lt;String&gt; nonRowIdentifyingColumns,
			final Collection&lt;ColumnMetadata&gt; nonRowIdentifyingColumnMetadata,
			final Map&lt;String, ColumnMetadata&gt; metaMapByColumn,
			final String[] groupNames) {
		int currentColumn = columnIndex;
		checkColumns(columns);
		ColumnMetadata column;
		for (final int rowidColumnIndex : sourceRowidColumnIndexes) {
			column = dataset.getMetadata().getColumnMetaData(rowidColumnIndex);
			final Style cellStyle = getStyle(baseStyle,
					column.getExcelFormat(), column.getHorizontalAlignment());
			if (column.getAggregateFunction() != null) {
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;emitting aggregate function &quot;
							+ column.getAggregateFunction() + &quot; at column &quot;
							+ columnIndex);
				}
				addColumnFormulaCell(rowIndex, currentColumn,
						firstDataRowIndex, lastDataRowIndex, cellStyle,
						column.getAggregateFunction());
			}
			currentColumn++;
		}
		int groupIndex = 0;
		for (final String groupName : groupNames) {
			final Map&lt;String, Integer&gt; columnIndexByName = ColumnMetadataGrouper
					.getColumnNameIndexMap(dataset, currentColumn,
							nonRowIdentifyingColumnMetadata, groupName);
			for (final String nonRowidColName : nonRowIdentifyingColumns) {
				Style cellStyle = null;
				final List&lt;Integer&gt; columnIndexes = (List&lt;Integer&gt;) dataset
						.getMetadata().getColumnIndexes(nonRowidColName);
				if (columnIndexes != null) {
					column = dataset.getMetadata().getColumnMetaData(
							columnIndexes.get(groupIndex));
				} else {
					column = metaMapByColumn.get(nonRowidColName);
					if (column == null) {
						throw new java.lang.IllegalStateException(
								&quot;No Metadata found &quot; + &quot; for column &quot;
										+ nonRowidColName);
					}
				}
				cellStyle = getStyle(baseStyle, column.getExcelFormat(),
						column.getHorizontalAlignment());
				column.setGroupName(groupName);
				if (column.getAggregateFunction() != null) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;emitting aggregate function &quot;
								+ column.getAggregateFunction() + &quot; at column &quot;
								+ columnIndex);
					}
					addColumnFormulaCell(rowIndex, currentColumn,
							firstDataRowIndex, lastDataRowIndex, cellStyle,
							column.getAggregateFunction());

				} else if (column.getWorkbookFormula() != null) {
					final HSSFCell cell = addFormulaCell(
							column.getWorkbookFormula(), columnIndexByName,
							column.getColumnName(), rowIndex, currentColumn);
					cell.setCellStyle(getStyleFactory().getHSSFCellStyle(
							cellStyle));
				}
				currentColumn++;
			}
			groupIndex++;
		}

	}

	/**
	 * TODO this should be deprecated
	 * 
	 * @param dataset
	 * @param startingRow
	 * @param startingColumn
	 * @param rowidColumnCount
	 * @return
	 */
	public DataRange emitCrosstabRegion(final Dataset dataset,
			final int startingRow, final int startingColumn,
			final int rowidColumnCount) {
		return emitCrosstabRegion(dataset, startingRow, startingColumn, null,
				null, null);
	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#737">737</a></td></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetRenderer.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetRenderer.html#692">692</a></td></tr><tr class="b"><td colspan='2'><div><pre>			addCell(column, baseStyle, rowIndex, columnIndex);
			columnIndex++;
		}
	}

	/**
	 * todo this started off the same as emitHeaders see what the difference is
	 * 
	 * @param columns
	 * @param baseStyle
	 * @param startingRow
	 * @param startingColumn
	 * @param nonRowIdentifyingColumns
	 * @param metadataByColumnName
	 */
	public void emitCrosstabHeadersForCrosstabData(final Dataset dataset,
			final String[] groupNames,
			final List&lt;String&gt; nonRowIdentifyingColumns,
			final Map&lt;String, ColumnMetadata&gt; metaByColumnName,
			final Style baseStyle, final int startingRow,
			final int startingColumn) {

		if (baseStyle == null) {
			throw new IllegalArgumentException(&quot;baseStyle is null&quot;);
		}
		baseStyle.setVerticalAlignment(VerticalAlignment.TOP);

		final int rowIndex = startingRow;
		int columnIndex = startingColumn;
		int groupIndex = 0;
		logger.trace(&quot;Starting Column is &quot; + startingColumn);
		ColumnMetadata column;

		for (final String groupName : groupNames) {
			logger.debug(&quot;Working with Group &quot; + groupName);
			for (final String nonRowidColName : nonRowIdentifyingColumns) {
				column = new ColumnMetadata();
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Working with Non Row Id Column &quot;
							+ nonRowidColName + &quot; expected at Index &quot;
							+ groupIndex);
				}
				final List&lt;Integer&gt; columnIndexes = (List&lt;Integer&gt;) dataset
						.getMetadata().getColumnIndexes(nonRowidColName);
				if (columnIndexes != null) {
					column = dataset.getMetadata().getColumnMetaData(
							columnIndexes.get(groupIndex));
				} else {
					column = metaByColumnName.get(nonRowidColName);
					if (column == null) {
						throw new java.lang.IllegalStateException(
								&quot;No Metadata found &quot; + &quot; for column &quot;
										+ nonRowidColName);
					}
				}
				column.setGroupName(groupName);
				addCell(column, baseStyle, rowIndex, columnIndex);
				columnIndex++;
			}
			groupIndex++;
		}
	}

	public int getEmittedColumnsInGroupCount() {

		throw new UnsupportedOperationException();
	}

	/**
	 * TODO this started off the same as emitHeaders see what the difference is
	 * 
	 * TODO do a cut and paste analysis
	 * 
	 * @param columns
	 * @param baseStyle
	 * @param startingRow
	 * @param startingColumn
	 * @param nonRowIdentifyingColumns
	 * @param nonRowIdentifyingColumns2
	 * @param metadataByColumnName
	 */
	public void emitCrosstabHeadersForCrosstabDataWithSpannedHeaders(
			final Dataset dataset,
			final String[] groupNames,
			final List&lt;String&gt; nonRowIdentifyingColumns,
			// List&lt;ColumnMetadata&gt; columns,
			final Map&lt;String, ColumnMetadata&gt; metaByColumnName,
			final Style baseStyle, final int startingRow,
			final int startingColumn) {

		if (baseStyle == null) {
			throw new IllegalArgumentException(&quot;baseStyle is null&quot;);
		}
		baseStyle.setVerticalAlignment(VerticalAlignment.TOP);

		final int rowIndex = startingRow;
		int columnIndex = startingColumn;
		int groupIndex = 0;
		logger.info(&quot;Starting Column is &quot; + startingColumn);
		ColumnMetadata column;

		for (final String groupName : groupNames) {
			logger.debug(&quot;Working with Group &quot; + groupName);
			int groupEntryIndex = 0;
			for (final String nonRowidColName : nonRowIdentifyingColumns) {
				column = new ColumnMetadata();
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Working with Non Row Id Column &quot;
							+ nonRowidColName + &quot; expected at Index &quot;
							+ groupIndex);
				}

				final List&lt;Integer&gt; columnIndexes = (List&lt;Integer&gt;) dataset
						.getMetadata().getColumnIndexes(nonRowidColName);
				if (columnIndexes != null) {
					column = dataset.getMetadata().getColumnMetaData(
							columnIndexes.get(groupIndex));
				} else {
					column = metaByColumnName.get(nonRowidColName);
					if (column == null) {
						throw new java.lang.IllegalStateException(
								&quot;No Metadata found &quot; + &quot; for column &quot;
										+ nonRowidColName);
					}
				}

				column.setGroupName(groupName);
				addGroupHeaderSpanCell(column, baseStyle, rowIndex,
						columnIndex, nonRowIdentifyingColumns.size(),
						groupEntryIndex++);
				columnIndex++;
			}
			groupIndex++;
		}
	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/SheetStyleHelper.java</td><td><a href="./xref/org/javautil/poi/SheetStyleHelper.html#153">153</a></td></tr><tr class="a"><td>org/javautil/poi/WorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/WorksheetHelper.html#205">205</a></td></tr><tr class="b"><td colspan='2'><div><pre>		final String firstAddress = CellAddress.getCellAddress(
				firstDataRowIndex, columnIndex);
		final String secondAddress = CellAddress.getCellAddress(
				lastDataRowIndex, columnIndex);
		final String formula = function + &quot;(&quot; + firstAddress + &quot;:&quot;
				+ secondAddress + &quot;)&quot;;
		final HSSFRow row = getRow(rowIndex);
		final HSSFCell cell = row.createCell(columnIndex);
		cell.setCellFormula(formula);
		final HSSFCellStyle hstyle = styleFactory.getHSSFCellStyle(style);
		cell.setCellStyle(hstyle);
		return cell;
	}

	HSSFRow getRow(final int index) {
		HSSFRow row = sheet.getRow(index);
		if (row == null) {
			row = sheet.createRow(index);

		}
		return row;
	}

	// todo this needs to be moved to a more common place
	public void fixColumnWidths(final int startColumnIndex,
			final int endColumnIndex) {
		for (int i = startColumnIndex; i &lt;= endColumnIndex; i++) {
			fixColumnWidth(i);
		}
	}

	public void setColumnWidth(final int columnIndex, final int characterWidth) {
		final int unitsPerChar = 300;
		final int funkyWidth = characterWidth * unitsPerChar;
		final short shortFunkyWidth = funkyWidth &lt; Short.MAX_VALUE ? (short) funkyWidth
				: Short.MAX_VALUE;
		sheet.setColumnWidth(columnIndex, shortFunkyWidth);
	}

	public void fixColumnWidth(final int columnIndex) {
		final int rowCount = sheet.getPhysicalNumberOfRows();
		int maxWidth = 0;
		for (int i = 0; i &lt; rowCount; i++) {
			final HSSFRow r = sheet.getRow(i);
			final HSSFCell c = r.getCell(columnIndex);

			if (c != null) {
				final String v = c.getStringCellValue();
				if (v != null &amp;&amp; v.length() &gt; maxWidth) {
					maxWidth = v.length();
				}
			}
		}
		if (maxWidth &gt; 8) {
			sheet.setColumnWidth(columnIndex, maxWidth);
		}
	}

	public void emitRegion(final Dataset dataset,</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#618">618</a></td></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetRenderer.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetRenderer.html#567">567</a></td></tr><tr class="b"><td colspan='2'><div><pre>	public void addGroupHeaderSpanCell(final ColumnMetadata column,
			final Style baseStyle, final int rowIndex, final int columnIndex,
			final int numberOfColumnsInGroup, final int groupEntryIndex) {
		Style cellStyle = null;
		String heading = &quot;&quot;;
		if (logger.isTraceEnabled()) {
			if (column.getHorizontalAlignment() == null) {
				logger.trace(&quot;horizontal alignment is null for &quot; + column);
			}
		}
		cellStyle = getStyle(baseStyle, null, column.getHorizontalAlignment());
		// now I need to get group heading
		// and column heading
		// with the row index one greater for the column

		if (groupEntryIndex == 0) {
			// emit merged group header
			final String groupName = column.getGroupName();
			// this cell Style should be centered ?? TODO unless there is only
			// one column in group?
			cellStyle = getStyle(baseStyle, null, HorizontalAlignment.CENTER);
			super.addCell(rowIndex, columnIndex, groupName, cellStyle);
			getSheet().addMergedRegion(new CellRangeAddress(rowIndex, // first
					// row
					// (0-based)
					rowIndex, // last row (0-based)
					columnIndex, // first column (0-based)
					columnIndex + numberOfColumnsInGroup - 1));
			if (logger.isDebugEnabled()) {
				final String message = &quot;creating group heading cell &quot;
						+ rowIndex + &quot; &quot; + columnIndex + &quot; &quot; + columnIndex
						+ numberOfColumnsInGroup + &quot; '&quot; + groupName + &quot;'&quot;;
				logger.debug(message);
			}
		}

		//

		heading = getNonmergedColumnHeading(column);
		if (heading.indexOf(&quot;\\n&quot;) &gt; -1) {
			heading = heading.replace(&quot;\\n&quot;, &quot;\n&quot;);
		}
		final int detailRowIndex = rowIndex + 1;
		if (logger.isDebugEnabled()) {
			final String message = &quot;creating group detail cell &quot;
					+ detailRowIndex + &quot; &quot; + columnIndex + &quot; &quot; + &quot; '&quot; + heading
					+ &quot;'&quot;;
			logger.debug(message);
		}
		super.addCell(detailRowIndex, columnIndex, heading, cellStyle);
		if (column.getColumnDisplaySize() != null) {
			setColumnWidth(columnIndex, column.getColumnDisplaySize()
					.intValue());
		}
	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/SheetStyleHelper.java</td><td><a href="./xref/org/javautil/poi/SheetStyleHelper.html#76">76</a></td></tr><tr class="a"><td>org/javautil/poi/WorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/WorksheetHelper.html#80">80</a></td></tr><tr class="b"><td colspan='2'><div><pre>					val = val.replace(&quot;\\n&quot;, &quot;\n&quot;);
				}
				cell.setCellValue(new HSSFRichTextString(val));
			} else if (value instanceof Boolean) {
				final Boolean bool = (Boolean) value;
				cell.setCellValue(bool.booleanValue());
			}
		} else {
			cell.setCellValue(&quot;&quot;);
		}
		if (style != null) {
			cell.setCellStyle(styleFactory.getHSSFCellStyle(style));
		}
		return cell;
	}

	public void addColumnSumCell(final int row, final int columnIndex,
			final int firstDataRowIndex, final int lastDataRowIndex,
			final Style style) {
		addColumnFormulaCell(row, columnIndex, firstDataRowIndex,
				lastDataRowIndex, style, &quot;sum&quot;);
	}

	public HSSFCell getCell(final int rownum, final int colnum) {
		final HSSFRow row = getRow(rownum);
		HSSFCell cell = row.getCell(colnum);
		if (cell == null) {
			cell = row.createCell(colnum);
		}
		return cell;
	}

	public HSSFCell addFormulaCell(final int rownum, final int columnIndex,
			final String formula, final Style style) {
		if (formula == null) {
			throw new IllegalArgumentException(&quot;formula is null&quot;);
		}

		final HSSFCell cell = getCell(rownum, columnIndex);
		cell.setCellFormula(formula);
		final HSSFCellStyle hstyle = styleFactory.getHSSFCellStyle(style);
		cell.setCellStyle(hstyle);
		return cell;
	}

	/**
	 * Creates a formula cell.
	 * 
	 * Example: to create a sum cell on
	 * 
	 * 
	 * @param rowIndex
	 *            The index (rownumber - 1) of the row into which the formula
	 *            should be placed
	 * @param columnIndex
	 *            The index of the column into which the formula should be
	 *            placed
	 * @param firstDataRowIndex
	 *            The index of the row that starts the range
	 * @param lastDataRowIndex
	 *            The index of the row that ends the rang
	 * @param style
	 *            The style of the cell containing the formula
	 * @param function
	 *            The function to be applied.
	 * @return
	 */
	public HSSFCell addColumnFormulaCell(final int rowIndex,
			final int columnIndex, final int firstDataRowIndex,
			final int lastDataRowIndex, final Style style, final String function) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/style/HSSFCellStyleFactory.java</td><td><a href="./xref/org/javautil/poi/style/HSSFCellStyleFactory.html#308">308</a></td></tr><tr class="a"><td>org/javautil/poi/style/PoiColor.java</td><td><a href="./xref/org/javautil/poi/style/PoiColor.html#43">43</a></td></tr><tr class="b"><td colspan='2'><div><pre>	}

	private HSSFColor getCachedHSSFColor(final Color color) {
		return colorCache.get(color);
	}

	private HSSFColor createHSSFColor(final Color color) {
		final HSSFPalette palette = getPalette();
		HSSFColor hssfColor = null;
		final byte r = (byte) color.getRed();
		final byte g = (byte) color.getGreen();
		final byte b = (byte) color.getBlue();
		hssfColor = palette.findColor(r, g, b);
		if (hssfColor == null) {
			try {
				final int index = getNextHSSFPaletteColorIndex();
				palette.setColorAtIndex((short) index, (byte) color.getRed(),
						(byte) color.getGreen(), (byte) color.getBlue());
				hssfColor = palette.getColor(index);
				if (hssfColor == null) {
					throw new IllegalStateException(
							&quot;invalid color created at index &quot; + index);
				}
			} catch (final Exception e) {
				hssfColor = palette.findSimilarColor(r, g, b);
				logger.warn(&quot;error after adding &quot; + colorCache.size()
						+ &quot; colors&quot;, e);
			}
		} else {
			reservedColorIndexes.add((int) hssfColor.getIndex());
		}
		colorCache.put(color, hssfColor);
		return hssfColor;
	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/style/HSSFCellStyleFactory.java</td><td><a href="./xref/org/javautil/poi/style/HSSFCellStyleFactory.html#267">267</a></td></tr><tr class="a"><td>org/javautil/poi/style/PoiFont.java</td><td><a href="./xref/org/javautil/poi/style/PoiFont.html#81">81</a></td></tr><tr class="b"><td colspan='2'><div><pre>	private void applyWrapStyle(final FontAttributes attr,
			final HSSFCellStyle cellStyle) {
		final String _wrapText = attr.get(FontAttributes.KEY_WORD_WRAP);
		if (_wrapText != null) {
			final boolean wrapText = Boolean.valueOf(_wrapText);
			cellStyle.setWrapText(wrapText);
		}
	}

	private void applyUnderlineStyle(final FontAttributes attr,
			final HSSFFont hssfFont) {
		final String _underlineStyle = attr
				.get(FontAttributes.KEY_UNDERLINE_STYLE);
		if (_underlineStyle != null) {
			byte hssfUnderline = org.apache.poi.ss.usermodel.Font.U_NONE;
			final FontUnderlineStyle underlineStyle = FontUnderlineStyle
					.valueOf(_underlineStyle);
			switch (underlineStyle) {
			case DOUBLE:
				hssfUnderline = org.apache.poi.ss.usermodel.Font.U_DOUBLE;
				break;
			case SINGLE:
				hssfUnderline = org.apache.poi.ss.usermodel.Font.U_SINGLE;
				break;
			case NONE:
				hssfUnderline = org.apache.poi.ss.usermodel.Font.U_NONE;
				break;
			default:
				throw new IllegalStateException(&quot;unimplemented underline case &quot;
						+ underlineStyle.toString());
			}
			hssfFont.setUnderline(hssfUnderline);
		}
	}

	public HSSFColor getHSSFColor(final Color color) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/style/HSSFCellStyleFactory.java</td><td><a href="./xref/org/javautil/poi/style/HSSFCellStyleFactory.html#160">160</a></td></tr><tr class="a"><td>org/javautil/poi/style/HSSFCellStyleFactory2.java</td><td><a href="./xref/org/javautil/poi/style/HSSFCellStyleFactory2.html#113">113</a></td></tr><tr class="b"><td colspan='2'><div><pre>				style.getFontAttributes(), style.getFontColor());
		s.setFont(hssfFont);
		if (style.getHorizontalAlignment() != null) {
			switch (style.getHorizontalAlignment()) {
			case LEFT:
				s.setAlignment(CellStyle.ALIGN_LEFT);
				break;
			case CENTER:
				s.setAlignment(CellStyle.ALIGN_CENTER);
				break;
			case RIGHT:
				s.setAlignment(CellStyle.ALIGN_RIGHT);
				break;
			default:
				throw new IllegalStateException(&quot;unimplemented halign case&quot;);
			}
		}
		if (style.getVerticalAlignment() != null) {
			switch (style.getVerticalAlignment()) {
			case TOP:
				s.setVerticalAlignment(CellStyle.VERTICAL_TOP);
				break;
			case MIDDLE:
				s.setVerticalAlignment(CellStyle.VERTICAL_CENTER);
				break;
			case BOTTOM:
				s.setVerticalAlignment(CellStyle.VERTICAL_BOTTOM);
				break;
			default:
				throw new IllegalStateException(&quot;unimplemented valign case&quot;);
			}
		}
		if (style.getFormatMask() != null) {
			s.setDataFormat(getFormat(style.getFormatMask()));
		}
		if (style.getFontAttributes() != null) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#509">509</a></td></tr><tr class="a"><td>org/javautil/poi/ListWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/ListWorksheetHelper.html#72">72</a></td></tr><tr class="b"><td colspan='2'><div><pre>					logger.trace(&quot;horizontal alignment is null for &quot; + column);
				}

				cellStyle = getStyle(baseStyle, null,
						column.getHorizontalAlignment());
				if (column.getGroupName() != null) {
					heading = column.getGroupName() + &quot;\n&quot;
							+ column.getHeading();
				} else {
					heading = column.getHeading();
				}
			}
			if (heading == null) {
				logger.warn(&quot;heading is null for &quot; + column);
			} else {
				if (heading.indexOf(&quot;\\n&quot;) &gt; -1) {
					heading = heading.replace(&quot;\\n&quot;, &quot;\n&quot;);
				}
			}
			if (heading.indexOf('\n') &gt; -1) {
				cellStyle = addWordWrap(cellStyle);
			}

			addCell(rowIndex, columnIndex, heading, cellStyle);
			if (column != null &amp;&amp; column.getColumnDisplaySize() != null) {
				setColumnWidth(columnIndex, column.getColumnDisplaySize()
						.intValue());
			}
			columnIndex++;
			entry++;
		}

	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#674">674</a></td></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetRenderer.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetRenderer.html#623">623</a></td></tr><tr class="b"><td colspan='2'><div><pre>	public void addCell(final ColumnMetadata column, final Style baseStyle,
			final int rowIndex, final int columnIndex) {
		if (logger.isDebugEnabled()) {
			logger.debug(&quot;writing cell &quot; + rowIndex + &quot; &quot; + columnIndex);
		}
		Style cellStyle = null;
		String heading = &quot;&quot;;
		if (logger.isTraceEnabled()) {
			if (column.getHorizontalAlignment() == null) {
				logger.trace(&quot;horizontal alignment is null for &quot; + column);
			}
		}
		cellStyle = getStyle(baseStyle, null, column.getHorizontalAlignment());
		heading = getMergedColumnHeading(column);

		if (heading.indexOf('\n') &gt; -1) {
			cellStyle = addWordWrap(cellStyle);
		}
		super.addCell(rowIndex, columnIndex, heading, cellStyle);
		if (column.getColumnDisplaySize() != null) {
			setColumnWidth(columnIndex, column.getColumnDisplaySize()
					.intValue());
		}
	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#549">549</a></td></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetRenderer.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetRenderer.html#498">498</a></td></tr><tr class="b"><td colspan='2'><div><pre>	private String getMergedColumnHeading(final ColumnMetadata column) {
		String heading = getNonmergedColumnHeading(column);

		String columnHeading = column.getHeading();
		if (columnHeading == null) {
			columnHeading = column.getColumnName();
		}
		if (columnHeading == null) {
			throw new IllegalStateException(&quot;no heading or columnName for &quot;
					+ column);
		}
		if (column.getGroupName() != null) {
			heading = column.getGroupName() + &quot;\n&quot; + columnHeading;
		}
		if (heading == null) {
			heading = columnHeading;
		} else {
			if (heading.indexOf(&quot;\\n&quot;) &gt; -1) {
				heading = heading.replace(&quot;\\n&quot;, &quot;\n&quot;);
			}
		}
		if (logger.isDebugEnabled()) {
			logger.debug(&quot;returned heading '&quot; + heading + &quot;'&quot;);
		}
		return heading;
	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/workbook/CellFormula.java</td><td><a href="./xref/org/javautil/workbook/CellFormula.html#39">39</a></td></tr><tr class="a"><td>org/javautil/workbook/CellFormula.java</td><td><a href="./xref/org/javautil/workbook/CellFormula.html#71">71</a></td></tr><tr class="b"><td colspan='2'><div><pre>			final int baseColumnIndex) {
		if (logger.isDebugEnabled()) {
			final StringBuilder sb = new StringBuilder();
			sb.append(&quot;template: '&quot; + template + SystemProperties.newline);
			for (final String name : columnMap.keySet()) {
				sb.append(&quot;name: '&quot; + name + &quot;' &quot; + columnMap.get(name)
						+ SystemProperties.newline);
			}
			sb.append(&quot;rowIndex: &quot; + rowIndex);
			logger.debug(sb);

		}
		final Set&lt;String&gt; variableNames = getVariableNames(template);
		String formula = template;
		for (final String var : variableNames) {
			final String cellAddress = getVariableNameAsCellAddress(var,
					columnMap, rowIndex);
			formula = formula.replaceAll(&quot;\\{&quot; + var + &quot;\\}&quot;, cellAddress);
		}
		return formula;
	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#772">772</a></td></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#841">841</a></td></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetRenderer.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetRenderer.html#727">727</a></td></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetRenderer.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetRenderer.html#796">796</a></td></tr><tr class="b"><td colspan='2'><div><pre>			for (final String nonRowidColName : nonRowIdentifyingColumns) {
				column = new ColumnMetadata();
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Working with Non Row Id Column &quot;
							+ nonRowidColName + &quot; expected at Index &quot;
							+ groupIndex);
				}
				final List&lt;Integer&gt; columnIndexes = (List&lt;Integer&gt;) dataset
						.getMetadata().getColumnIndexes(nonRowidColName);
				if (columnIndexes != null) {
					column = dataset.getMetadata().getColumnMetaData(
							columnIndexes.get(groupIndex));
				} else {
					column = metaByColumnName.get(nonRowidColName);
					if (column == null) {
						throw new java.lang.IllegalStateException(
								&quot;No Metadata found &quot; + &quot; for column &quot;
										+ nonRowidColName);
					}
				}
				column.setGroupName(groupName);</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/style/HSSFCellStyleFactory.java</td><td><a href="./xref/org/javautil/poi/style/HSSFCellStyleFactory.html#240">240</a></td></tr><tr class="a"><td>org/javautil/poi/style/PoiFont.java</td><td><a href="./xref/org/javautil/poi/style/PoiFont.html#41">41</a></td></tr><tr class="b"><td colspan='2'><div><pre>			final Color color) {
		final HSSFFont hssfFont = getWorkbook().createFont();

		if (color != null) {
			final HSSFColor hssfColor = getHSSFColor(color);
			if (hssfColor != null) {
				hssfFont.setColor(hssfColor.getIndex());
			}
		}
		if (font != null) {
			// todo jjs where did these constants come from
			hssfFont.setBoldweight((short) (font.isBold() ? 0x2bc : 0x190));
			hssfFont.setItalic(font.isItalic());
			final int fontOneTwentiethPoints = font.getSize() * 20;
			hssfFont.setFontHeight((short) fontOneTwentiethPoints);
			hssfFont.setFontName(font.getName());
		}
		if (attr != null) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#583">583</a></td></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetRenderer.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetRenderer.html#532">532</a></td></tr><tr class="b"><td colspan='2'><div><pre>	private String getNonmergedColumnHeading(final ColumnMetadata column) {
		String heading = null;

		String columnHeading = column.getHeading();
		if (columnHeading == null) {
			columnHeading = column.getColumnName();
		}
		if (columnHeading == null) {
			throw new IllegalStateException(&quot;no heading or columnName for &quot;
					+ column);
		}

		if (heading == null) {
			heading = columnHeading;
		} else {
			if (heading.indexOf(&quot;\\n&quot;) &gt; -1) {
				heading = heading.replace(&quot;\\n&quot;, &quot;\n&quot;);
			}
		}
		if (logger.isDebugEnabled()) {
			logger.debug(&quot;returned heading '&quot; + heading + &quot;'&quot;);
		}
		return heading;
	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="a"><th>File</th><th>Line</th></tr><tr class="b"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#435">435</a></td></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetRenderer.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetRenderer.html#434">434</a></td></tr><tr class="b"><td>org/javautil/poi/ListWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/ListWorksheetHelper.html#183">183</a></td></tr><tr class="a"><td colspan='2'><div><pre>				column.setGroupName(groupName);
				if (column.getAggregateFunction() != null) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;emitting aggregate function &quot;
								+ column.getAggregateFunction() + &quot; at column &quot;
								+ columnIndex);
					}
					addColumnFormulaCell(rowIndex, currentColumn,
							firstDataRowIndex, lastDataRowIndex, cellStyle,
							column.getAggregateFunction());

				} else if (column.getWorkbookFormula() != null) {
					final HSSFCell cell = addFormulaCell(
							column.getWorkbookFormula(), columnIndexByName,
							column.getColumnName(), rowIndex, currentColumn);
					cell.setCellStyle(getStyleFactory().getHSSFCellStyle(
							cellStyle));
				}
				currentColumn++;
			}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/javautil/poi/ListWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/ListWorksheetHelper.html#104">104</a></td></tr><tr class="b"><td>org/javautil/poi/SheetStyleHelper.java</td><td><a href="./xref/org/javautil/poi/SheetStyleHelper.html#296">296</a></td></tr><tr class="a"><td colspan='2'><div><pre>	}

	/**
	 * 
	 * @param dataset
	 * @param columns
	 * @param baseStyle
	 * @return the row index of the last row generated
	 */
	protected int emitData(final Dataset dataset,
			final List&lt;ColumnMetadata&gt; columns, final Style baseStyle,
			final int startingRow, final int startingColumn) {
		if (dataset == null) {
			throw new IllegalArgumentException(&quot;dataset is null&quot;);
		}
		if (columns == null) {
			throw new IllegalArgumentException(&quot;columns is null&quot;);
		}
		if (baseStyle == null) {
			throw new IllegalArgumentException(&quot;baseStyle is null&quot;);
		}
		final Map&lt;String, Integer&gt; columnIndexByName = ColumnMetaMap
				.getColumnNameIndexMap(columns);

		final DatasetIterator datasetIterator = dataset.getDatasetIterator();
		int rowIndex = startingRow;
		while (datasetIterator.next()) {</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/javautil/poi/WorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/WorksheetHelper.html#153">153</a></td></tr><tr class="b"><td>org/javautil/poi/WorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/WorksheetHelper.html#201">201</a></td></tr><tr class="a"><td colspan='2'><div><pre>	public HSSFCell addColumnFormulaCell(final int rowIndex,
			final int columnIndex, final int firstDataRowIndex,
			final int lastDataRowIndex, final Style style, final String function) {

		final String firstAddress = CellAddress.getCellAddress(
				firstDataRowIndex, columnIndex);
		final String secondAddress = CellAddress.getCellAddress(
				lastDataRowIndex, columnIndex);
		final String formula = function + &quot;(&quot; + firstAddress + &quot;:&quot;
				+ secondAddress + &quot;)&quot;;
		final HSSFRow row = getRow(rowIndex);
		final HSSFCell cell = row.createCell(columnIndex);
		cell.setCellFormula(formula);
		final HSSFCellStyle hstyle = styleFactory.getHSSFCellStyle(style);
		cell.setCellStyle(hstyle);
		return cell;
	}</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/javautil/poi/style/HSSFCellStyleFactory.java</td><td><a href="./xref/org/javautil/poi/style/HSSFCellStyleFactory.html#205">205</a></td></tr><tr class="b"><td>org/javautil/poi/style/HSSFCellStyleFactory2.java</td><td><a href="./xref/org/javautil/poi/style/HSSFCellStyleFactory2.html#158">158</a></td></tr><tr class="a"><td colspan='2'><div><pre>		final HSSFCellStyleFactory factory = new HSSFCellStyleFactory(workbook);
		final Map&lt;String, HSSFCellStyle&gt; hssfCellStyles = new LinkedHashMap&lt;String, HSSFCellStyle&gt;();
		for (final Style style : styles) {
			if (style == null) {
				throw new IllegalStateException(&quot;style is null&quot;);
			}
			final HSSFCellStyle hssfCellStyle = factory.getHSSFCellStyle(style);
			final String styleName = style.getName();
			hssfCellStyles.put(styleName, hssfCellStyle);
		}
		return hssfCellStyles;
	}

	private short getFormat(final String formatMask) {
		final HSSFDataFormat format = workbook.createDataFormat();
		final short formatIndex = format.getFormat(formatMask);
		return formatIndex;
	}

	public HSSFFont getHSSFFont(final Font font, final FontAttributes attr,</pre></div></td></tr></table><table border="0" class="bodyTable"><tr class="b"><th>File</th><th>Line</th></tr><tr class="a"><td>org/javautil/poi/CrosstabbedWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/CrosstabbedWorksheetHelper.html#486">486</a></td></tr><tr class="b"><td>org/javautil/poi/ListWorksheetHelper.java</td><td><a href="./xref/org/javautil/poi/ListWorksheetHelper.html#50">50</a></td></tr><tr class="a"><td colspan='2'><div><pre>	public void emitCrosstabHeaders(final List&lt;ColumnMetadata&gt; columns,
			final Style baseStyle, final int startingRow,
			final int startingColumn,
			final List&lt;String&gt; nonRowIdentifyingColumns,
			final Map&lt;String, ColumnMetadata&gt; metadataByColumnName) {

		if (baseStyle == null) {
			throw new IllegalArgumentException(&quot;baseStyle is null&quot;);
		}

		final int rowIndex = startingRow;
		int columnIndex = startingColumn;
		int entry = 0;
		for (final ColumnMetadata column : columns) {

			Style cellStyle = null;
			String heading = &quot;&quot;;
			if (column == null) {
				logger.warn(&quot;null column at entry &quot; + entry);
				cellStyle = baseStyle;
			} else {

				if (logger.isTraceEnabled()) {</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                   2012.
          All Rights Reserved.      
        
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
